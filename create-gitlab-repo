#!/usr/bin/env python
import argparse
import json
import logging
import os.path
import urllib.request, urllib.error, urllib.parse

import xdg.BaseDirectory

from configparser import SafeConfigParser
from subprocess import CalledProcessError, check_call, check_output

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('--server', help='label for a Gitlab server')
arg_parser.add_argument('--name', help='name of the created repository')
arg_parser.add_argument('--log', help='logging level', choices=['DEBUG','INFO','WARNING','ERROR','CRITICAL'])
args = arg_parser.parse_args()

# assuming loglevel is bound to the string value obtained from the
# command line argument. Convert to upper case to allow the user to
# specify --log=DEBUG or --log=debug
numeric_log_level = getattr(logging, args.log.upper(), None)
if not isinstance(numeric_log_level, int):
    raise ValueError('Invalid log level: %s' % args.log)

logging.basicConfig(format='%(levelname)s:%(funcName)s:%(message)s',
                    level=numeric_log_level)

def get_config(section):
    gitlab_config_file = os.path.join(xdg.BaseDirectory.xdg_config_home,
                                      'gitlab')
    conf_parser = SafeConfigParser()
    conf_parser.read(gitlab_config_file)

    if section is not None:
        cur_site = section
    elif conf_parser.has_section('general'):
        cur_site = conf_parser.get('general', 'default')
    else:
        cur_site = conf_parser.sections()[0]

    token = conf_parser.get(cur_site, 'token')
    base_url = conf_parser.get(cur_site, 'base_url')
    return token, base_url

gitlab_token, gitlab_base_url = get_config(args.server)

curdir = os.path.abspath(os.curdir)
pkgname = os.path.basename(curdir)

reponame = args.name.strip() if args.name is not None else pkgname

try:
    # collect description
    desc = input('Enter a brief description of the project:\n').strip()
    logging.debug('desc = "{}"'.format(desc))
    if len(desc) == 0:
        raise KeyboardInterrupt('Premature termination')

    # create repo on remote site
    req = urllib.request.Request(url='{}/projects/'.format(gitlab_base_url))
    req.add_header('PRIVATE-TOKEN', gitlab_token)
    paras = {
        'name': reponame,
        'descripton': desc,
        'wiki_enabled': 'false',
        'merge_requests_enabled': 'true',
        'issues_enabled': 'true',
        'public': 'true',
    }
    req.data = str.encode(urllib.parse.urlencode(paras))
    logging.debug('req:\n%s', str(req))
    logging.debug('req:\n%s', req.get_full_url())
    logging.debug('req:\n%s', req.data)
    logging.debug('req:\n%s', req.header_items())
    ret = urllib.request.urlopen(req)

    logging.debug('retcode = %d', ret.getcode())
    if ret.getcode() != 201:
        raise Exception('Failed to create project: response code: {}'.
                format(ret.reason()))

    body = ret.read()
    response = json.loads(body.decode())
    logging.debug('response:\n%s', str(response))

    push_url = response['ssh_url_to_repo']
    pull_url = response['http_url_to_repo']
    project_id = response['id']
    logging.debug('project_id = %d' % project_id)

    # set up remotes
    check_call(['git', 'remote', 'add', 'gitlab', pull_url])
    check_call(['git', 'remote', 'set-url', '--push', 'gitlab', push_url])

except CalledProcessError:
    pass

except KeyboardInterrupt:
    pass

